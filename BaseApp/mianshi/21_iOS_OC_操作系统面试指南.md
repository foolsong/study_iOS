## iOS/Objective-C 操作系统面试 Q&A 精选（清晰题干 + 详解）

1) 问：iOS 为何没有交换分区（swap），这对内存管理与稳定性有什么影响？
   答：iOS 出于性能与能耗考虑不支持 swap，物理内存耗尽时由 Jetsam 杀死高占用进程。影响：
   - 必须严格控制峰值内存（图片/视频解码、缓存上限、@autoreleasepool 分批释放）。
   - 内存告警（UIApplicationDidReceiveMemoryWarning）要有清理策略；OOM 难以捕获，只能通过现场还原与指标监控复盘。
   - 频繁触顶会触发系统回收，前台体验陡降或被杀，需在性能关键页（Feed、编辑器）避免同持大量大对象。

2) 问：在 OC 工程中如何正确使用 QoS 与 GCD 避免 UI 卡顿？
   答：
   - 将非 UI 任务分发到合适 QoS：User-Interactive（极少使用，仅用于马上影响交互的任务）、User-Initiated（用户触发并希望尽快完成）、Utility（可感知但不紧急）、Background（不可感知的后台工作）。
   - 避免在主队列同步（sync）提交，防止死锁；长任务切片后台化，合并结果回主线程。
   - I/O、压缩、加密等重任务设 Utility/Background；动画/滚动期间降低非关键任务优先级。

3) 问：RunLoop 有哪些模式？为何滚动时某些定时器不触发？如何规避？
   答：
   - 常见模式：default、tracking、common。滚动时 RunLoop 处于 tracking 模式，默认模式下的定时器与源不被调度。
   - 规避：将定时器加入 common modes，或在滚动结束后再提交相关任务；关键 UI 更新需考虑模式切换影响。

4) 问：ARC 下最常见的三类循环引用与工程化断环方式？
   答：
   - Block 持有 self、self 持有 Block → 使用 weak/strong dance 或中间代理对象；避免长期持有的 closure 捕获强引用。
   - NSTimer/CADisplayLink 强持有目标 → 使用中间代理或 block 计时器，视图消失/对象释放时及时失效。
   - Delegate/DataSource 强引用回环 → 约定 weak；跨模块协议明确生命周期与所有权边界。

5) 问：如何降低磁盘 I/O 对主线程与能耗的影响？
   答：
   - 后台队列批处理写入；合并小写为大块；避免滚动期间进行同步 I/O。
   - 大文件读取可用 mmap 降低拷贝；下载/上传使用 URLSession 背景会话，交给系统调度以优化功耗。

6) 问：后台任务与能耗控制的工程做法？
   答：
   - 使用 Background Tasks/Background Fetch 处理非实时工作，设置合适任务过期处理与条件（充电/Wi‑Fi）。
   - 定位/蓝牙/音频等后台模式要最小权限最短时长，并向用户明确说明，避免被系统限制或用户拒绝。

7) 问：沙盒目录如何选？缓存、用户数据与临时数据分别放哪里？
   答：
   - Documents：用户数据（需 iCloud 备份）；Library/Caches：可清理缓存（不备份）；tmp：临时文件（系统可清理）。
   - 大缓存适合 Caches；临时下载过程文件放 tmp；重要持久数据放 Documents 并做好迁移策略。

---

## iOS/Objective-C 操作系统面试指南（iOS 语境）

聚焦 iOS 运行时环境下的 OS 知识：进程与线程、调度与优先级、内存管理（虚拟内存、物理内存、ARC 与对象布局）、文件与 IO、沙盒与权限、系统服务与能耗、锁与并发、RunLoop/后台任务。

---

### 1. 进程、线程与调度

- 进程：独立地址空间，App 沙盒隔离；系统通过 Jetsam 对高内存进程进行回收。
- 线程：共享进程资源；主线程承担 UI 与 RunLoop 事件；过多线程会增加上下文切换与内存。
- 调度：基于优先级与 QoS（User-Interactive / User-Initiated / Utility / Background）；合理设置 QoS，避免后台任务抢占主线程资源。

---

### 2. 并发模型与锁机制（OC 视角）

- GCD（libdispatch）
  - 串行/并发队列、同步/异步提交、栅栏、信号量、调度源；避免在主队列同步死锁。
  - QoS 继承与传播：任务以最高 QoS 为准，注意滥用导致资源紧张。

- NSOperation
  - 在 GCD 之上的抽象：依赖、取消、重试、队列并发控制；适合复杂依赖任务。

- 锁与同步
  - 自旋锁、互斥锁、读写锁、信号量、条件锁；避免长时间持锁与在锁内进行 IO。
  - 原子性：`atomic` 仅保证 getter/setter 原子，不保证更高层操作的原子性。

---

### 3. 内存与对象管理

- 虚拟内存与物理内存
  - 虚拟内存页映射、页面置换；iOS 无交换分区（swap），内存耗尽将被 Jetsam 杀死。

- ARC 与对象生命周期
  - 引用计数（retain/release/autorelease）；循环引用场景（Block、Timer、Delegate）与断环策略。
  - AutoreleasePool：RunLoop 边界自动释放；批处理大对象时应手动建立小粒度池。

- 对象布局
  - isa、引用计数、对象头；Tagged Pointer 提升小对象性能；结构体与对象的栈/堆分配差异。

---

### 4. 文件系统、IO 与网络

- 沙盒目录：`Documents`（用户数据）、`Library/Caches`（可清理缓存）、`tmp`（临时文件，系统可清理）。
- IO 策略：避免主线程磁盘 IO；批处理写入；使用文件映射（mmap）优化大文件读写。
- 后台传输：`URLSession` 背景会话提升可靠性与能耗表现。

---

### 5. 能耗与后台执行

- 省电策略
  - 合并任务、批处理网络；空闲/充电/Wi‑Fi 时执行非关键任务；定位/蓝牙/音频使用最小权限与最短时间。

- 后台模式
  - Background Fetch、Background Processing、音频/定位持续；必须严格控制资源并告知用户。

---

### 6. RunLoop 与事件源

- RunLoop 模式：`default`、`tracking`、`common`；滚动时仅 `tracking` 模式运行，避免在默认模式调度关键 UI 更新。
- 观察者与定时器：定时器加入适当模式；避免过密触发带来唤醒与能耗。

---

### 7. 安全与权限

- 沙盒与权限模型：按需申请摄像头/麦克风/定位；最小化 Info.plist 权限描述；数据最小化原则。
- Keychain：敏感数据加密存储；使用访问组共享与生物特征解锁。

---

### 8. 场景题与工程取舍

- 场景：聊天 App 消息收发与图片上传同时进行导致卡顿。
  - 解法：为图片上传设定较低 QoS；限流并发；在非主线程进行编码/压缩；主线程仅分发小事务。

- 场景：后台定位导致耗电高、被系统限制。
  - 解法：按需切换准确度与频率；地理围栏替代持续高频定位；在可用时改用显著位置变化服务。

- 场景：频繁的磁盘写导致掉帧。
  - 解法：聚合写入、批处理；使用后台队列；在滚动期间降级非关键 IO。

---

面试回答建议：围绕“资源受限”的 iOS 环境（无 swap、强沙盒、严格能耗）展开，以 QoS/RunLoop/ARC/沙盒 与 观测（Instruments/日志）的闭环说明取舍与复盘。


