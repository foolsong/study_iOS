## iOS（Objective-C）性能与优化实践指南

面向实际工程的 OC 优化手册，覆盖：启动优化、UITableView 优化、内存管理与泄漏治理、卡顿与掉帧治理、包体积优化、动态库与静态库对比与选型。以描述为主，辅以可落地的检查清单与真实场景案例。

---

### 1. 启动优化（App Launch Optimization）

目标：缩短从点击图标到首屏可交互的时间。分阶段分析和优化：dyld 阶段（动态链接）、runtime 阶段（ObjC 注册、类/分类）、main 之前（静态初始化）、main 之后（AppDelegate/首屏链路）。

- 核心概念与阶段
  - 冷启动（Cold Start）：进程首次启动，包含 dyld 加载、rebase/bind、代码签名验证、ObjC 元数据注册、C/ObjC 静态初始化、main 进入、UIApplicationMain、首屏渲染。
  - 预主阶段（pre-main）：可通过环境变量或工具（如 Instruments 的 Time Profiler + DYLD_PRINT_STATISTICS）度量。
  - 首屏关键路径：首屏所需资源、组件初始化、首屏接口与数据依赖、首屏渲染（首个可交互帧）。

- 高成本点与治理策略
  - +load 与静态初始化
    - 问题：过多/耗时的 `+load`、C++ 全局构造、繁重的静态变量初始化会阻塞 pre-main。
    - 策略：避免在 `+load` 做耗时工作；能挪到 `+initialize` 或懒加载就懒加载；将初始化拆到首屏后或后台异步；聚合/去重多处重复初始化。
  - 动态库数量与层级
    - 问题：动态库过多增加 dyld 工作量（rebase/bind、依赖解析、代码签名验证），拉长启动。
    - 策略：合并业务动态库为少量宏包（FeaturePack）；第三方库优先使用静态链接；避免深层级依赖链。
  - ObjC 元数据注册
    - 问题：类/分类/方法过多增加 runtime 注册成本。
    - 策略：精简无用类别与方法；移除无用符号（Dead Code Stripping）；代码拆分到按需加载的模块。
  - 首屏资源与布局
    - 问题：首屏大量图片解码、复杂 Auto Layout、同步 IO、主线程 JSON 解析导致阻塞。
    - 策略：首屏所需资源最小化；图片使用合适分辨率并开启延迟解码；布局尽量简单直观；IO/解析放子线程；优先渲染骨架屏或占位。
  - 首屏网络依赖
    - 问题：强依赖多个接口返回，串行等待。
    - 策略：强弱依赖分层；并发请求；可用降级/缓存；业务可交互先于完整渲染。

- 可落地检查清单（启动）
  - 检查是否存在 `+load` 中的耗时操作（日志、网络、磁盘、复杂计算）。
  - 统计动态库数量与依赖深度，能合并即合并；第三方能静态化就静态化。
  - 确认首屏仅加载必要类与资源；移除无用类、分类与图片资源。
  - 将大 JSON 解析、配置加载、埋点初始化挪到首屏后/后台。
  - 骨架屏/占位图先渲染，真实数据异步填充。

- 真实场景示例
  - 大型电商 App：`+load` 中初始化埋点与广告 SDK，pre-main 升至 600ms+。将初始化改为 main 之后、首屏渲染完成后再延迟启动，pre-main 降至 200ms 左右，首屏时间缩短 ~350ms。
  - 社交 App：业务拆分成 30+ 动态库，dyld 阶段耗时显著。将业务库合并为 5 个 FeaturePack，并把若干第三方改为静态库，冷启动缩短 ~25%。

---

### 2. UITableView 优化（含 UICollectionView 同理）

目标：在大数据量、复杂 Cell 的场景下保持流畅滚动与稳定内存占用。

- 数据与布局策略
  - 严格复用：确保复用标识一致；避免在 `cellForRow` 无谓创建子视图；子视图层级扁平化。
  - 高度计算：避免复杂的动态高度同步计算；使用缓存（Height Cache）；尽量使用约束稳定的自适应方案并缓存结果。
  - 预取与分页：开启 `prefetchDataSource`；分页加载；首屏渲染优先关键区域，列表滚动后懒加载非关键资源。
  - 图片处理：异步解码与缩放；使用合适尺寸与格式；滚动时可降低解码优先级或暂停非关键解码。
    - 解码与渲染分离：使用后台队列 + Image I/O 完成解码/下采样，主线程仅显示位图结果。
    - 下采样策略：按目标显示像素（视图尺寸 × 屏幕 scale）计算 `maxPixelSize`，避免原图尺寸解码导致内存峰值。
    - 格式选择：不透明摄影类优先 JPEG/HEIF（体积小）；需透明通道用 PNG/WebP；动图使用 APNG/WebP 动图并限制帧缓存数。
    - 请求与滚动协同：滚动快速时暂停低优先级图片请求与解码；Cell 离屏立即取消请求，避免无效解码与带宽浪费。
    - 缓存分层：内存 LRU + 磁盘缓存，Key 包含 URL + 目标尺寸 + scale + 裁剪/填充模式，避免缓存命中误用。
  - 纯文本与富文本：复杂富文本在后台预排版，缓存 NSAttributedString 或布局结果。

- 绘制与渲染
  - 避免离屏渲染：尽量不使用 `maskToBounds + cornerRadius`、阴影、复杂渐变；若必须，使用预渲染的圆角图片或异步绘制。
  - 异步绘制：将文本排版、图片混排放到后台线程生成位图（如 CoreText + CGBitmapContext），主线程仅显示结果位图。
  - 批量更新：批处理 `reload/insert/delete/move`；避免频繁 `reloadData`；使用 Diff 算法（如 diffable 数据源思想）降低刷新成本。

- 线程与 RunLoop
  - 避免在主线程做磁盘 IO/网络/大 JSON 解析；滑动期间降低非关键任务优先级。
  - 使用 RunLoop 观察者批量提交 UI 更新，减少提交帧内的布局与绘制压力。

- 可落地检查清单（列表）
  - 是否开启并实现数据预取；是否有滚动时进行大图解码/缩放。
  - 是否存在 `willDisplay` 中的重计算或网络请求。
  - 是否缓存了高度、富文本排版结果、图片解码结果。
  - 是否规避了常见离屏渲染触发点；是否使用了异步绘制方案。

- 真实场景示例
  - 内容信息流：Cell 内含多张大图与富文本，滚动卡顿明显。将图片后台解码缩放；富文本提前排版并缓存布局；圆角替换为预渲染位图；卡顿从 70ms+ 降至 10ms 以内，FPS 稳定 55-60。

---

### 3. 内存优化（Memory）

目标：降低峰值内存、避免泄漏与野指针、稳定内存波动，降低被系统杀死的风险。

- 泄漏与循环引用
  - Block 循环引用：`self` 在 block 内长期持有且 block 被对象属性强持有，导致循环。通过 `__weak`/`__unsafe_unretained` 断环，或引入中间对象。
  - 委托与数据源：默认强引用易造成环；约定使用 `assign/weak`（在 ARC 下用 `weak`，非 ARC 场景谨慎 `assign`）。
  - NSTimer/CADisplayLink：目标强引用导致循环；使用中间代理或 block 计时器，或在 `dealloc`/`viewWillDisappear` 及时失效。

- AutoreleasePool 与峰值控制
  - 大量临时对象（图片解码、字符串拼接、大字典遍历）应在显式 `@autoreleasepool` 中批量释放，避免峰值拖尾。
  - 循环中注意 autoreleased 对象的累积，必要时在小粒度循环内部加入 `@autoreleasepool`。

- 图片与缓存策略
  - 图片内存：按需缩放到展示尺寸；避免同时持有原图与缩放图；使用 `NSCache` 控制淘汰；必要时落盘缓存。
  - 大对象生命周期：使用弱持有与“使用即取，用完即丢”的策略；按场景设定缓存上限与清理时机（内存告警时清理）。
  - 加载流程（数据流）：网络/磁盘 → 数据缓冲区 → Image I/O 读取头部（尺寸、EXIF、色彩空间）→ 依据目标视图计算下采样参数 → 解码为位图（BGRA/sRGB）→ 主线程渲染。
  - 下采样实现要点：使用 CGImageSource（懒加载读取元数据），创建缩略图时设置 `kCGImageSourceCreateThumbnailFromImageAlways = true`、`kCGImageSourceThumbnailMaxPixelSize = max(displayW*scale, displayH*scale)`，避免全尺寸解码。
  - 线程与释放：解码应在后台队列，并在循环或批量处理中包裹 `@autoreleasepool`；主线程仅进行 `UIImageView.image = decodedImage` 的轻量操作。
  - 色彩空间：统一到 sRGB 渲染，避免色彩空间转换带来的额外内存与 CPU；关闭不必要的 ICC Profile 解析。
  - 动图优化：限制并控制帧缓存数量（如仅缓存前后 2-3 帧），按需解码下一帧；对高分辨率动图优先使用视频方案或降分辨率。
  - 磁盘缓存：分级目录与最大体积上限，LRU 淘汰；文件名采用内容哈希，元信息记录像素尺寸/scale，便于命中后直接判断是否可用。
  - 预取与降级：首屏与即将可见区域优先；弱网展示缩略图/低清图，点击或稳定后再加载原图；支持渐进式 JPEG/分块渲染以改善感知。

  - 超大图优化（专题）：
    - 分块/区域解码：对长图/大图使用 `CGImageCreateWithImageInRect` 进行分片，只解需要的可见区域。
    - 瓦片渲染：使用 `CATiledLayer` 与缩放等级（levelsOfDetail），随缩放按需加载与渲染瓦片，控制单帧内存与 CPU。
    - 滚动/缩放协同：配合 `UIScrollView` 缩放，低倍率时优先显示低分辨率总览贴图，高倍率时懒加载局部高清瓦片。
    - 显存与内存控制：避免同时持有原图、全尺寸位图与多级缩略图；限定并发解码数与瓦片大小，优先级随交互动态调整。
    - 典型场景：长图（Feed 长图、漫画）、超高像素全景图、离线大图预览；策略是“所见即所得”只解可见区并分级缓存。

- CoreFoundation 与 ARC 桥接
  - 避免不对称的 Create/Copy/Retain 与 Release；注意 `__bridge`/`__bridge_retained`/`__bridge_transfer` 的对称关系，防泄漏或野指针。

- 可落地检查清单（内存）
  - 是否存在 Block/Timer/通知未释放导致的循环引用。
  - 大循环是否包裹 `@autoreleasepool`；图片是否按显示尺寸解码。
  - 是否使用 `NSCache` 并设置上限；内存告警是否设置清理策略。
  - CF 与 ObjC 桥接是否对称；第三方库是否有已知泄漏问题。

- 真实场景示例
  - 短视频列表：同时缓存原视频帧与解码帧导致内存峰值过高被系统回收。改为分辨率自适应、滑出视野即释放、只缓存关键帧缩略，峰值下降 35%+。

---

### 4. 卡顿与掉帧治理（Jank/Stutter）

目标：稳定 60 FPS（或 120 FPS 的设备下尽量保持高帧率），避免主线程长任务阻塞与 GPU 过载。

- 主线程负载
  - 避免长任务（> 8-12ms）在主线程执行：IO、解码、加密、JSON 解析、图片缩放。
  - 将计算/布局前移或后台化：预计算布局、异步绘制、结果缓存。

- GPU/渲染压力
  - 离屏渲染触发点控制：圆角+裁剪、阴影、蒙版、复杂透明叠加；通过预渲染位图、快照或简化层次规避。
  - 大视图层级与透明：减少层级与透明通道混合；能合并就合并；避免不必要的 `alpha` 动画。

- RunLoop 与事务
  - 使用 RunLoop 观察丢帧（如监控主线程卡顿栈）；在合适的 RunLoop 模式与时机提交 UI 更新。
  - 批量事务：将多次细碎 UI 改动合并到一次动画事务中提交。

- 可落地检查清单（卡顿）
  - 是否存在滑动中进行图片解码/数据库查询。
  - 是否存在圆角+阴影的组合；是否有超大图直接缩放显示。
  - 是否对主线程长任务做了切分与后台化；是否做了掉帧监控和栈上报。

- 真实场景示例
  - 复杂消息会话页：输入时卡顿。剖析发现主线程同步计算富文本与表情排版。改为后台排版、结果缓存，输入响应时间从 120ms 降至 20ms 内。

---

### 5. 包体积优化（App Size）

目标：降低 IPA 安装包体积与首次下载大小，缩短安装时间并提升转化率。

- 资源治理
  - 图片资源：使用合适格式（HEIC/PNG/JPEG，按内容选择）；避免重复资源；使用 Asset Catalog；拆分 1x/2x/3x 并清理未用切图。
  - 音视频与字库：裁剪到必要子集；按需下载（On-Demand Resources）；避免在包内放大体积资源。

- 代码与符号
  - Dead Code Stripping：开启无用符号剔除；链接时优化（LTO/LLVM 优化选项）。
  - 第三方库：移除未使用架构（只保留 arm64）；能源码引入的尽量源码；必要时做自定义精简构建。

- 切分与按需
  - App Thinning：Slicing + Bitcode（注意当前生态对 Bitcode 的支持变化，可仅使用 Slicing）；拆分资源面向不同设备投递。
  - 功能模块化：非常规功能改为按需下载包或首次使用时解压加载。

- 可落地检查清单（体积）
  - 是否存在重复图片、无用资源；是否使用 Asset Catalog 管理。
  - 是否移除了未用架构与调试符号；是否开启 Dead Code Stripping。
  - 大模型/字库/视频等是否按需下载；是否使用 ODR。

- 真实场景示例
  - 工具类 App：历史累积 3 套图标资源和多语言字库，清理未用资源、裁剪字库子集、启用 slicing 后，包体积从 210MB 降至 125MB。

---

### 6. 动态库 vs 静态库（Dynamic vs Static Library）

从启动、体积、内存共享、更新灵活性四个维度进行对比与选型。

- 启动
  - 动态库：dyld 需要进行 rebase/bind、代码签名验证与依赖加载，库数量越多成本越高；过多动态库显著拖慢冷启动。
  - 静态库：在链接期被合入可执行文件，启动阶段开销较小。

- 体积与内存
  - 动态库：可在多 App 间共享系统框架，但第三方动态库一般不能共享；符号与元数据单独存在，可能增加总体占用。
  - 静态库：与主二进制打包在一起，便于 Dead Code Stripping，通常更利于体积控制。

- 更新与热插拔
  - 动态库：理论上便于替换与版本化管理，但 iOS 对第三方动态链接的权限与分发限制较多，不能像 macOS 那样灵活。
  - 静态库：更新需重新打包应用，但行为更可控、启动更稳定。

- 工程选型建议
  - 业务模块优先静态库；大量细碎模块合并成少量静态包。
  - 非首屏强依赖的可考虑动态框架，但避免过多；严格控制依赖链深度。
  - 第三方 SDK 如仅提供动态库，评估其对启动的影响并延迟初始化。

---

### 7. 观测与度量（Observability）

优化必须以数据驱动：统一采集、稳定度量、分阶段目标。

- 指标体系
  - 启动：冷启动/热启动耗时、pre-main 时间、首帧/首屏可交互时间。
  - 性能：FPS、长帧分布（> 16.7ms/33ms/50ms）、主线程阻塞段栈。
  - 内存：峰值、均值、波动、OOM 率、告警频率与清理效果。
  - 体积：安装包大小、资源分类占比、不同切片体积。

- 工具与方法
  - Instruments：Time Profiler（启动/CPU）、Core Animation（掉帧）、Allocations/Leaks、Memory Graph、Network。
  - 线上监控：卡顿监控（RunLoop/信号+栈采样）、启动链路打点、内存告警与 OOM 还原、A/B 实验平台验证效果。

---

### 8. 综合实战路线（可复用于大型 OC 工程）

1) 启动优化 0→1
  - 统计 pre-main；审计 `+load`/静态初始化；合并/静态化第三方库；首屏骨架先行。
2) 列表优化 0→1
  - 预取/分页、异步解码与富文本后台排版、缓存高度与布局、规避离屏渲染。
3) 内存与卡顿 0→1
  - 建立循环引用与泄漏扫描；大循环加 `@autoreleasepool`；掉帧监控与主线程长任务下沉。
4) 体积 0→1
  - 资源清理与格式治理；剔除未用架构；功能按需化；链接期剔除无用符号。

---

### 9. 面试延展问题（便于口述）

- 如何界定“首屏可交互”？你在工程中如何落地该定义并对齐产品？
- 遇到业务强依赖首屏接口时如何保交互流畅？骨架屏与降级策略如何设计？
- UITableView 的高度缓存与数据变更一致性如何保证？
- 遇到“圆角+阴影”强需求时如何既保真又提速？
- 如何系统化避免 Block 循环引用、Timer 泄漏与桥接不对称？
- 在你的项目里，动态库与静态库的边界如何划分？遇到三方仅支持动态库时如何管控启动影响？

---

以上内容以 Objective-C 工程为主线，强调“度量—定位—优化—回归”的闭环与对首屏/列表/内存/体积四大维度的系统性治理，适用于中大型商业应用的长期演进与质量控制。



