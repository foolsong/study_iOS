## iOS/Objective-C 算法面试 Q&A 精选（清晰题干 + 详解）

1) 问：移动端为何更偏好 O(nlogn) 以内的算法？
   答：CPU/内存受限且 UI 主线程预算约 16.7ms/帧，O(n^2) 在中等规模就会卡顿。策略是数据分批、异步化、增量化与结果缓存，避免阻塞主线程。

2) 问：如何在信息流中实现高效的增量刷新？
   答：使用 Diff 思想生成最小变更集（insert/delete/move），避免 `reloadData`；对比唯一标识与版本戳，配合批量更新与高度/布局缓存，稳定 60FPS。

3) 问：TopK 统计在本地如何做？
   答：单遍计数 + 小顶堆 O(nlogk)，内存受限时分桶+外排；注意键空间大时使用哈希压缩或近似结构（Count-Min Sketch）。

4) 问：前缀联想与本地搜索如何设计？
   答：Trie 或有序数组 + 二分；内存大的 Trie 需压缩（DAWG/共享前缀），热词 LRU 缓存；异步计算分页返回，避免主线程阻塞。

5) 问：如何在滚动列表中平衡精确与性能？
   答：复杂度高的文本排版与图片处理放后台，主线程只接收位图/排版结果；必要时采用近似（例如估算高度后回填修正）。

---

## iOS/Objective-C 算法面试指南（工程化思维）

强调时间/空间复杂度、工程边界（内存、功耗、实时性）、移动端弱网/IO 特性下的算法取舍与常见题型思路。尽量语言化描述，少量伪代码/术语。

---

### 1. 复杂度与工程约束

- 复杂度评估：时间 O(·) 与空间 O(·)；常见量级区别（O(nlogn) 与 O(n^2) 的临界 n）。
- 移动端约束：内存严格、CPU 受限、UI 主线程时限（~16.7ms/帧）。
- 策略：重计算 → 缓存；同步 → 异步；全量 → 增量；精确 → 近似。

---

### 2. 高频题型与思路

- 数组与双指针
  - 有序合并、去重、窗口和；滑动窗口用于子数组统计与最长子串。

- 哈希与计数
  - 两数之和、频次统计、去重；空间换时间的典型思路。

- 排序与选择
  - 快排/堆排序；TopK 使用小顶堆 O(nlogk)；稳定性与内存权衡。

- 树与图
  - 二叉树遍历（前中后/层序）、最近公共祖先；图的 BFS/DFS、最短路（Dijkstra/BFS）。

- 动态规划
  - 子结构、状态定义与转移；经典：背包、最长上升子序列、编辑距离。

- 字符串与匹配
  - KMP、Trie、Rolling Hash；Emoji/Unicode 正确处理与本地化注意事项。

---

### 3. iOS 实战中的算法化解法

- 列表 Diff 与增量刷新
  - 使用 diff 思想计算最小变更集（insert/delete/move），降低 `reloadData` 开销。

- 图片与文本处理
  - 缩略与裁剪采用线性时间算法并后台化；富文本排版结果缓存。

- 离线排序与合并
  - 大数据分页获取后在本地按时间/权重合并，TopK 展示；注意内存峰值与懒序列。

---

### 4. 典型场景题（口述版）

- 场景：百万级日志中找最频繁的 100 个事件。
  - 解法：单遍计数 + 小顶堆（O(nlogk)），或分桶+外排；注意内存与 IO。

- 场景：聊天记录搜索高亮与前缀联想。
  - 解法：Trie 或倒排索引；移动端可用分词+LRU 缓存最近词条；异步计算结果分页返回。

- 场景：信息流去重与曝光控制。
  - 解法：Bloom Filter 近似去重（低内存）、Redis 侧准确去重；客户端维持滑动窗口曝光集。

---

### 5. 复杂度与可观测性

- 通过埋点记录输入规模、运行时长、内存峰值；出现退化时触发回退路径（如改用近似算法）。

---

面试给分点：能清晰描述复杂度、举出工程边界、提出降级与回退方案、说明如何监控正确性与性能，并有真实缺陷复盘案例。


