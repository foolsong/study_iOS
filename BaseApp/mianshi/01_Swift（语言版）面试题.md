# Swift面试题（语言化答案，少代码）

本文件以语言描述为主，覆盖Swift语法、类型系统、内存与并发、协议与泛型、API 设计与工程实践等常见面试题。适合口述与白板面试，尽量减少代码依赖。

## 1. 语言与范式

- 问题：Swift 与 Objective‑C 的核心差异？
  - 答案（语言版）：Swift 强类型 + 类型推断，错误更早暴露；强调值语义与面向协议，默认不可变；可选类型将“无值”显式化，减少运行期崩溃。OC 偏动态与引用语义，空消息容忍度高但易隐藏问题。二者可互操作，但在模块化、命名与可见性上需额外设计。

- 问题：值语义与引用语义如何取舍？
  - 答案（语言版）：默认优先值类型（结构体/枚举），利于并发安全与推理，适合数据模型与配置。需要身份、共享可变状态、继承或与 OC 交互时再选引用类型（类）。

- 问题：面向协议编程（POP）相对继承的优势？
  - 答案（语言版）：协议定义能力边界，支持多重遵循；配合扩展可提供默认实现，避免深层继承树，提升解耦与可测试性；与泛型结合可获得静态派发与优化。

## 2. 可选类型与错误边界

- 问题：为什么需要可选类型（Optional）？
  - 答案（语言版）：用类型系统显式表达“可能缺失”，避免空引用错误；在 API 层清楚标注输入输出的可空性。

- 问题：几种常见解包策略及适用场景？
  - 答案（语言版）：可选绑定与 guard 早返回是首选；可选链用于逐步访问；空合并为缺省值；强制解包仅在 100% 确定非空时使用。

- 问题：何时用 Optional、何时用 throws？
  - 答案（语言版）：可预期“缺失”用 Optional；可恢复的业务失败用 throws 或 Result；开发者错误或不变量违背用断言/前置条件。

## 3. 函数、闭包与捕获

- 问题：逃逸与非逃逸闭包的区别？
  - 答案（语言版）：非逃逸闭包在当前作用域内执行，默认更安全；逃逸闭包可能延后执行，需注意循环引用与生命周期管理。

- 问题：如何避免闭包循环引用？
  - 答案（语言版）：使用捕获列表（weak/unowned）打破环；weak 更安全（可能置空），unowned 更高效（须保证被捕获对象生命周期）。

- 问题：尾随闭包与函数式思维带来的好处？
  - 答案（语言版）：让异步/组合式代码更接近业务表达，提升可读性与抽象能力。

## 4. 属性、下标与访问控制

- 问题：存储属性、计算属性、属性观察器的差异？
  - 答案（语言版）：存储负责持久化数据；计算按需派生，不存储值；观察器在变更前后触发，用于联动逻辑与校验。

- 问题：类型属性与单例的关系？
  - 答案（语言版）：类型属性与类型绑定，常用于共享配置或缓存；单例可通过私有初始化 + 静态属性实现，但应慎用，防止全局状态污染与难测试。

- 问题：访问控制等级如何选择？
  - 答案（语言版）：默认 internal；库对外 API 用 public/open（open 允许外部继承/重写）；模块内细化用 fileprivate/private 控制暴露面，利于封装。

## 5. 协议、泛型与类型抹消

- 问题：协议与泛型分别解决什么问题？
  - 答案（语言版）：协议关注“能力”抽象，适合面向接口编程与解耦；泛型关注“类型参数化”，提升复用与类型安全。两者结合可获得静态派发与更好性能。

- 问题：where 子句与关联类型的价值？
  - 答案（语言版）：让约束更精准，避免 Any 与运行期错误；面向调用方提供更清晰的能力边界。

- 问题：何时需要类型抹消（Type Erasure）？
  - 答案（语言版）：当对外暴露的泛型过于复杂或造成二次泛型污染时，用类型抹消提供稳定、简洁的抽象，内部保留灵活实现。

## 6. 字符串与集合

- 问题：Swift 字符串为什么不能简单下标整数？
  - 答案（语言版）：基于 Unicode 扩展字形集，字符宽度不定，长度与索引并非 O(1)。需通过索引 API 安全访问。

- 问题：Substring 与 String 的关系？
  - 答案（语言版）：Substring 可能共享底层存储，长时间持有会阻止原字符串释放；在需要长期保存时建议显式构造新的 String。

- 问题：集合的写时复制（CoW）有什么影响？
  - 答案（语言版）：读多写少性能好；大量写操作需关注复制成本，可通过预分配或自定义存储优化。

## 7. ARC、所有权与内存泄漏

- 问题：Swift 中常见的泄漏来源？
  - 答案（语言版）：对象间相互强引用、闭包强捕获 self、计时器/通知中心强持有、缓存未清理等。

- 问题：如何系统治理泄漏与循环引用？
  - 答案（语言版）：正确使用 weak/unowned，设计合理所有权；在 deinit 中清理；解除通知/观察；结合 Memory Graph/Leaks 工具定位与验证。

## 8. 并发（Swift Concurrency）

- 问题：相比 GCD，async/await 的本质收益？
  - 答案（语言版）：让异步流程线性化，错误与取消语义自然传播，代码更可读；可与 Task/TaskGroup 并行构建，并通过 Actor 隔离共享可变状态。

- 问题：Actor 解决什么问题？
  - 答案（语言版）：以单线程化的方式保护内部可变状态，避免数据竞争；对外提供异步接口，牺牲一定吞吐换来正确性与可维护性。

## 9. API 设计与模块化

- 问题：优秀的 Swift API 应具备哪些特征？
  - 答案（语言版）：命名一致性与语义明确；最小必要暴露；输入输出显式化，少副作用；错误边界清晰；易测与可扩展。

- 问题：如何在团队中推广 POP 与值语义？
  - 答案（语言版）：通过实践组件化、协议抽象、测试替身案例，配合代码评审与基准模板，引导一致的工程习惯。

## 10. 性能与启动优化

- 问题：常见性能优化抓手？
  - 答案（语言版）：数据结构与算法选择；减少不必要拷贝；异步解码/渲染；批量化 I/O；避免主线程拥塞；用 Instruments 做数据驱动优化。

- 问题：应用启动如何优化？
  - 答案（语言版）：减少动态库与全局副作用；懒加载与延迟初始化；二进制重排；避免阻塞主线程；按阶段度量与回归。

## 11. 典型开放题（扩展题库）

1) 何时优先选择 protocol 而不是 class？给出三个工程级理由。
2) 解释值语义如何帮助并发安全，并举业务场景说明收益。
3) 设计分页加载与去重策略，说明取消、合并与错误降级方案。
4) 谈谈类型抹消（type erasure）的理解与适用边界。
5) 如何让一个泛型 API 在不牺牲可读性的前提下保持易用？
6) 你在实际项目中如何推动 POP 与值语义落地？


