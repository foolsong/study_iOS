## iOS/Objective-C 数据结构面试 Q&A 精选（清晰题干 + 详解）

1) 问：为什么 NSCache 常用于图片/对象缓存，而不是直接用 NSMutableDictionary？
   答：NSCache 支持自动逐出策略（受内存压力影响）、线程安全与可设置上限，避免崩溃风险；Dictionary 无逐出机制、需自管淘汰且线程不安全。

2) 问：如何在客户端实现线程安全的 LRU？
   答：哈希表 O(1) 定位 + 双向链表 O(1) 调整 + 互斥/读写锁；或使用并发队列做写串行、读并行；淘汰触发异步释放，避免阻塞。

3) 问：TopK/优先任务调度为何选最小堆？
   答：最小堆支持 O(logn) 插入与 O(1) 取最小，适合维护下一到期任务或固定大小的 TopK；排序数组插入代价高，链表查找代价高。

4) 问：Trie 在移动端的内存问题如何缓解？
   答：共享前缀、节点压缩、稀疏子节点用哈希表；只对高频词构建 Trie，其余走后端；结果分页并缓存热路径。

5) 问：布隆过滤器适合哪些客户端场景？
   答：本地去重与曝光控制、日志去重、拦截重复请求；以极低内存代价换小概率误判，可接受时很划算。

---

## iOS/Objective-C 数据结构面试指南（选型与取舍）

结合 Foundation/CF 容器与常用结构（数组、链表、队列、栈、堆、哈希、树/Trie、跳表、布隆过滤器），强调特性、复杂度、线程安全与内存表现，以及 iOS 场景化选型。

---

### 1. 基础容器（OC 语境）

- NSArray/NSMutableArray（顺序表）
  - 随机访问 O(1)，尾部插入 O(1) 摊还；中间插入/删除 O(n)。
  - 适用：有序小集合、频繁随机访问的列表；不适合大量中间插入。

- NSDictionary/NSMutableDictionary（哈希表）
  - 平均 O(1) 查找/插入；哈希冲突退化；Key 必须实现哈希与等价性。
  - 适用：映射与计数；注意不可变/可变的线程安全边界。

- NSSet/NSMutableSet（哈希集合）
  - 去重与成员判断 O(1)；适合过滤与存在性查询；有序需求改用 NSOrderedSet。

---

### 2. 进阶结构与实现要点

- 链表（单/双）
  - 插入/删除 O(1)，查找 O(n)；常用于 LRU 的双向链表部分；OC 下自定义节点结构体或对象。

- 队列与栈
  - 队列：BFS/生产消费者；栈：表达式与回溯；可用 `NSMutableArray` 尾进头出模拟。

- 堆（优先队列）
  - 小顶/大顶堆；TopK、定时任务、滑动窗口中值；CFBinaryHeap 或自实现二叉堆。

- 树/Trie
  - 搜索、区间、前缀匹配；联系人搜索、输入法词典；内存占用高，需压缩与共享前缀。

- 跳表
  - 有序集合的近似平衡结构，插入/查找 O(logn)，实现简单；服务端 Redis 常见，客户端偶尔用于有序索引。

- 布隆过滤器（Bloom Filter）
  - 低内存近似去重，存在小概率误判（假阳）；适用于本地快速去重/拦截。

---

### 3. 线程安全与复制语义

- 不可变容器可在多线程并发读；可变容器需外部同步或使用自建并发安全结构。
- Copy/MutableCopy：确保在跨线程传递或需要快照时使用拷贝；注意深浅拷贝差异与内存开销。

---

### 4. 典型工程场景选型

- 缓存（LRU/LFU）
  - LRU：哈希表 O(1) 定位 + 双向链表 O(1) 调整；NSCache 内置近似策略并带自动清理。

- 搜索联想
  - Trie/有序数组二分搜索；热词优先与频率衰减；与本地化/Unicode 兼容。

- 任务调度
  - 最小堆维护下一到期任务；与 RunLoop/Timer 配合，避免大量定时器。

- 去重与曝光
  - 小集合用 NSSet；海量用 Bloom Filter；跨会话持久化使用哈希摘要集合。

---

### 5. 面试延展问题

- 如何在 OC 中实现一个线程安全的 LRU 缓存？如何定义淘汰策略与上限？
- 为什么选择堆而不是排序数组实现优先队列？在 iOS 中如何落地？
- Trie 在移动端如何降低内存压力？是否需要压缩存储或磁盘索引？

---

回答建议：围绕复杂度、空间占用、线程安全与 iOS 约束（内存、功耗、主线程时限）阐述取舍，并结合可观测性与回归验证。


